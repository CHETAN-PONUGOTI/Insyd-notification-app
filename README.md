1. Introduction
  This document outlines the design and implementation of a proof-of-concept (POC) notification system for Insyd, a social web platform for the Architecture Industry. The goal is to design a scalable and efficient system that keeps users engaged by providing timely updates on activities from followed users, followers, or organic content discovery.

  The assignment is divided into two parts:

  Part 1:
    System Design Document: A comprehensive document detailing the system architecture, data flow, scalability, and performance considerations for both an initial scale of 100 daily active users (DAUs) and a future scale of 1 million DAUs.

Part 2:
  POC App: A functional application built with a ReactJS frontend and a NodeJS backend to demonstrate the core functionality of the notification system.

2. System Overview
  The notification system is designed to handle events generated by user actions, process them, and deliver timely in-app notifications to the relevant users. For the POC, the focus is on a streamlined system for a bootstrapped startup, with a clear roadmap for scaling to a large user base.

Key features:

  Notification Types: Likes, comments, follows, new posts, or messages.
  Delivery Channel: In-app notifications (for POC simplicity).
  Core Components: Event Source, Notification Service, Database, Message Queue, Frontend Client, and Delivery Service.

3. System Architecture
  The architecture is designed to be event-driven, ensuring scalability and decoupling of components. The following diagram illustrates the high-level architecture:

Components and Interactions
  Component	Description
  Event Source	Triggers events based on user actions (e.g., a user clicking 'like' on a post). For the POC, this is handled directly by the backend API.
  Message Queue	An asynchronous communication channel (e.g., Kafka, RabbitMQ, or a simple in-memory queue for the POC) that handles event processing. It decouples the event source from the notification service.
  Notification Service	The core business logic component. It consumes events from the message queue, retrieves user preferences, and generates notification messages. It then stores the notification in the database.
  Database	Stores all relevant data, including user profiles, posts, events, and a log of all generated notifications. For the POC, a simple document database like MongoDB is sufficient.
  Frontend Client	A ReactJS application that polls the backend API at regular intervals to check for new notifications and displays them to the user.
  Delivery Service	Responsible for sending the notification to the user. For the POC, this is a simple REST endpoint that the frontend polls. At scale, this would be expanded to include WebSockets, push notifications, and emails.

  Flow of Execution
    A user performs an action (e.g., likes a post), which serves as an Event Source.
    The backend API publishes a new event (e.g., POST_LIKED) to the Message Queue.
    The Notification Service consumes the event from the queue.    
    The service processes the event, retrieves the necessary user and post data from the Database, and generates a new notification entry.  
    The generated notification is stored in the Database.   
    The Frontend Client (ReactJS app) periodically polls the backend's Delivery Service endpoint for new notifications.    
    The Delivery Service retrieves new notifications from the database and sends them to the frontend.    
    The frontend displays the new notifications to the user.

4. Data Design
  For the POC, a simple schema for a MongoDB database is proposed.

Collections
  Collection	Fields	Description
  users	_id, username, email	Stores user information.
  notifications	_id, recipient_id, actor_id, type, target_id, is_read, created_at	Stores notification data. recipient_id is the user receiving the notification, actor_id is the user who triggered the event, and target_id refers to the post or comment.
  events	_id, event_type, data, timestamp	A log of all system events. For the POC, this is simplified, as events are processed directly from the queue.

5. Scalability and Performance
  The system is designed to scale from 100 to 1 million DAUs with minimal architectural changes.

For 100 DAUs (POC)
  Single Server: A single NodeJS server can handle all components.
  Database: A single MongoDB instance is more than sufficient.
  Message Queue: A simple in-memory queue or direct function calls can simulate the message queue functionality.

For 1 Million DAUs
  Horizontal Scaling: Deploy multiple instances of the NodeJS Notification Service and Delivery Service behind a load balancer.
  Database Sharding: Use sharding for the notifications database to distribute data and load across multiple servers.
  Real Message Queue: Implement a robust message queue like Kafka to handle the high volume of events and ensure reliable processing.
  Caching: Implement caching layers (e.g., Redis) for frequently accessed data like user preferences or recent notifications to reduce database load.
  Delivery: Replace polling with WebSockets for real-time, low-latency notification delivery. This reduces the number of requests and provides an instant user experience.

Performance Optimizations
  Indexing: Create indexes on key database fields (e.g., recipient_id, created_at) to ensure fast notification retrieval.
  Asynchronous Processing: The event-driven architecture ensures that notification generation doesn't block the user-facing application, providing a responsive experience.
  Rate Limiting: Implement rate limiting on the notification generation process to prevent a single user from spamming others with excessive notifications.

6. Limitations and Trade-offs
  Polling vs. WebSockets: The POC uses polling for simplicity. This is less efficient than WebSockets, as it can introduce latency and generate unnecessary requests. However, it is a suitable and simpler solution for a small user base.
  Lack of Caching: The POC does not include caching as per the assignment constraints. This could become a performance bottleneck at a large scale.
  Single Server Bottleneck: At the 1 million DAU scale, a single server would not be able to handle the load and would require horizontal scaling.

7. POC Implementation Plan
  Backend (NodeJS)
    API Endpoints:
      POST /events/like: Simulates a user liking a post, triggering a notification.
      GET /notifications: Retrieves notifications for the authenticated user.
      PUT /notifications/:id/read: Marks a notification as read.
      Database: Use Mongoose to interact with a local or hosted MongoDB instance.
      Notification Logic: Implement a simple function that generates and stores notifications based on event data.
      Event Simulation: For the POC, direct function calls can simulate an event being pushed to a message queue.

  Frontend (ReactJS)
    Components:
    Header: A component that displays a notification icon.
    NotificationsDropdown: A dropdown list that appears when the user clicks the icon, showing their unread notifications.
    NotificationItem: A single component to render each notification in the list.

State Management: Use React's built-in useState and useEffect hooks to manage notification data and poll the backend API at a fixed interval (e.g., every 5 seconds).

API Integration: Use fetch or axios to make GET and PUT requests to the backend API.
